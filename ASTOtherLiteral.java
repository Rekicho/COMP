
/* Generated By:JJTree: Do not edit this line. ASTOtherLiteral.java Version 6.0 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=false,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
import java.util.Iterator;
import java.util.Set;

public class ASTOtherLiteral extends SimpleNode {
	String type = "";
	String identifier = "";

	public ASTOtherLiteral(int id) {
		super(id);
	}

	public ASTOtherLiteral(jmm p, int id) {
		super(p, id);
	}

	public String toString() {
		switch (type) {
		case "[]":
			return "[...]";
		case "length":
			return "length";
		case "call":
			return "call: " + identifier;
		}

		return "";
	}

	public String semanticAnalysis(SymbolTable table, String functionName) throws Exception {
		super.semanticAnalysis(table, functionName);

		if (!(parent instanceof ASTLiteral))
			throw new Exception("Expression " + ((ASTOtherLiteral) parent).type + "found before expression");

		ASTLiteral literal = (ASTLiteral) parent;

		switch (type) {
		case "[]":
			if (!literal.isArray(table, functionName))
				throw new Exception(literal.identifier + " is not an array.");

			SimpleNode n = (SimpleNode) ((SimpleNode)parent).children[0];

			if (!n.semanticAnalysis(table, functionName).equals("int"))
				throw new Exception("Integer Expression expected inside []");

			return "[]";

		case "length":
			if (!literal.isArray(table, functionName))
				throw new Exception(literal.identifier + " is not an array.");

			return "int";

		case "call":
			if (table.functions.get(identifier) == null)
				return "";

			Set<String> keys = table.functions.get(identifier).params.keySet();
			Iterator<String> it = keys.iterator();
			int i = 0;

			if (children == null || children.length == 0) {
				if (keys.size() != 0)
					throw new Exception(
							"Function call " + identifier + " expected " + keys.size() + " parameters but found 0.");
			}

			else {
				ASTMethodParams methodParams = (ASTMethodParams) children[0];

				String[] params = methodParams.getParams(table, functionName);

				for (; i < params.length && it.hasNext(); ++i) {
					String key = (String) it.next();
					Symbol value = (Symbol) table.functions.get(identifier).params.get(key);

					if (!params[i].equals(value.type))
						throw new Exception("Function call " + identifier + " parameter " + i + " expected: "
								+ value.type + " found: " + params[i] + ".");
				}

				if (i < params.length || it.hasNext())
					throw new Exception("Function call " + identifier + " expected " + keys.size()
							+ " parameters but found " + params.length + ".");

			}

			return table.functions.get(identifier).returnType;
		}

		return "";
	}

	public void generateCode(StringBuilder builder, SymbolTable ST, String functionName) {
		if(children != null) {
			((ASTMethodParams) children[0]).generateCode(builder,ST,functionName);
			return;
		}
		
		ASTLiteral parentNode = (ASTLiteral) parent;

		if(type.equals("[]")) {
			Symbol symbol;
			if ((symbol = ST.functions.get(functionName).locals.get(parentNode.identifier)) != null) {
				builder.append("aload " + symbol.order + "\n");
			}
			else if ((symbol = ST.functions.get(functionName).params.get(parentNode.identifier)) != null) {
				builder.append("aload " + symbol.order + "\n");
			}
			else if((symbol = ST.symbols.get(parentNode.identifier)) != null) {
				builder.append("aload_0\ngetfield " + ST.className + "/" + identifier + " [I\n");
			}

			((SimpleNode)(parentNode.children[0])).generateFunctionCode(builder, ST, functionName);
			builder.append("iaload\n"); 
			return;
		}

		if(type.equals("length")) {
			Symbol symbol;
			if ((symbol = ST.functions.get(functionName).locals.get(parentNode.identifier)) != null) {
				builder.append("aload " + symbol.order + "\n");
			}
			else if ((symbol = ST.functions.get(functionName).params.get(parentNode.identifier)) != null) {
				builder.append("aload " + symbol.order + "\n");
			}
			else if((symbol = ST.symbols.get(parentNode.identifier)) != null) {
				builder.append("aload_0\ngetfield " + ST.className + "/" + identifier + " [I\n");
			}
			builder.append("arraylength\n"); 
			return;
		}

		Symbol symbol = null;

		if(parentNode.identifier.equals("this")) {
			builder.append("aload_0\n");
		}

		else if(functionName != null && (symbol = ST.functions.get(functionName).params.get(parentNode.identifier)) != null && symbol.type.equals(ST.className)) {
			builder.append("aload " + symbol.order + "\n");
		}

		else if(functionName != null && (symbol = ST.functions.get(functionName).locals.get(parentNode.identifier)) != null && symbol.type.equals(ST.className)) {
			builder.append("aload " + symbol.order + "\n");
		}

		else if((symbol = ST.functions.get(functionName).locals.get(parentNode.identifier)) != null && symbol.type.equals(ST.className)) {
			builder.append("aload_0\ngetfield " + ST.className + "/" + identifier + " L\n");
		}

		else if(parentNode.identifier.contains("new")) {
			String className = parentNode.identifier.split("new ")[1];
	
			builder.append("new " + className + "\ndup\ninvokespecial " + className + "/<init>()V\n");
		}

		if(parentNode.identifier.equals("this") || parentNode.identifier.equals("new " + ST.className) || (symbol != null && symbol.type.equals(ST.className))) {
        	builder.append("invokevirtual " + ST.className + "." + identifier + "()");

		if(ST.functions.get(identifier).returnType.equals("boolean"))
			builder.append("Z");

		else if(ST.functions.get(identifier).returnType.equals("int"))
			builder.append("I" );

		else if(ST.functions.get(identifier).returnType.equals("int[]"))
			builder.append("[I" );

        else if(ST.functions.get(identifier).returnType.equals(ST.className))
          builder.append("L" + ST.className);

        else builder.append("Ljava/lang/" + identifier + ";");

        builder.append("\n");
      }

      else {
        if(parentNode.identifier.contains("new ")) {
          String function = parentNode.identifier.split("new ")[1];
          builder.append("invokevirtual " + function + "." + identifier + "()V\n");
        }
          
		else if(parentNode.identifier.contains("io") || parentNode.identifier.contains("MathUtils"))
			builder.append("invokestatic " + parentNode.identifier + "." + identifier + "()V\n");
		
		else builder.append("invokestatic java/lang/" + parentNode.identifier + "." + identifier + "()V\n");
      }
    }
}
/*
 * JavaCC - OriginalChecksum=6a67081bb7fb5f77aa5f878ca7d3dcab (do not edit this
 * line)
 */
