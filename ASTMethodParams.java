/* Generated By:JJTree: Do not edit this line. ASTMethodParams.java Version 6.0 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=false,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
import java.util.Iterator;

public
class ASTMethodParams extends SimpleNode {
  public ASTMethodParams(int id) {
    super(id);
  }

  public ASTMethodParams(jmm p, int id) {
    super(p, id);
  }

  public String[] getParams(SymbolTable table, String functionName) throws Exception {
      String[] res = new String[children.length];

      for (int i = 0; i < children.length; ++i) {
				SimpleNode n = (SimpleNode) children[i];
				res[i] = n.semanticAnalysis(table,functionName);
			}

      return res;
  }

  public void generateCode(StringBuilder builder, SymbolTable ST, String functionName) {
    ASTOtherLiteral parentNode = (ASTOtherLiteral) parent;
	ASTLiteral parentparentNode = (ASTLiteral) parentNode.parent;

    if (parentNode.type.equals("call")) {
		Symbol symbol = null;

      if(parentparentNode.identifier.equals("this")) {
        builder.append("aload_0\n");
	  }

		else if(functionName != null && (symbol = ST.functions.get(functionName).params.get(parentparentNode.identifier)) != null) {
			builder.append("aload " + symbol.order + "\n");
		}

		else if(functionName != null && (symbol = ST.functions.get(functionName).locals.get(parentparentNode.identifier)) != null) {
			builder.append("aload " + symbol.order + "\n");
		}

		else if((symbol = ST.functions.get(functionName).locals.get(parentparentNode.identifier)) != null) {
			builder.append("aload_0\ngetfield " + ST.className + "/" + parentNode.identifier + " L\n");
		}

      else if(parentparentNode.identifier.contains("new ")) {
        String className = parentparentNode.identifier.split("new ")[1];

        builder.append("new " + className + "\ndup\ninvokespecial " + className + "/<init>()V\n");
      }

		if (children != null) {
			for (int i = 0; i < children.length; i++) {
				((SimpleNode) children[i]).generateFunctionCode(builder, ST, functionName);
			}
		}
      
      if(parentparentNode.identifier.equals("this") || parentparentNode.identifier.contains("new ") || symbol != null)
			{
		String className;

		if(symbol != null)
			className = symbol.type;

		else if(parentparentNode.identifier.equals("this"))
			className = ST.className;

		else className = parentparentNode.identifier.split("new ")[1];

		builder.append("invokevirtual " + className + "." + parentNode.identifier + "(");

		if(className.equals(ST.className) && ST.functions.get(parentNode.identifier) != null) {
			Iterator<Symbol> it = ST.functions.get(parentNode.identifier).params.values().iterator();

			while(it.hasNext()) {
			  String type = it.next().type;
	
			  if(type.equals(ST.className))
				builder.append("L" + type);
	
			  else if(type.equals("boolean"))
				builder.append("Z");
	
			  else if(type.equals("int"))
				builder.append("I");
				
			  else if(type.equals("int[]"))
				builder.append("[I");
			  
			  else builder.append("Ljava/lang/" + type + ";");
			}
	
			builder.append(")");
	
			if(ST.functions.get(parentNode.identifier).returnType.equals("boolean"))
				builder.append("Z");
	
			else if(ST.functions.get(parentNode.identifier).returnType.equals("int"))
				builder.append("I" );
	
			else if(ST.functions.get(parentNode.identifier).returnType.equals("int[]"))
				builder.append("[I" );
	
			else if(ST.functions.get(parentNode.identifier).returnType.equals(ST.className))
			  builder.append("L" + ST.className);
	
			else builder.append("Ljava/lang/" + parentNode.identifier + ";");

					
			if(!isStore(1))
				builder.append("\npop");

			builder.append("\n");
		}

		else {
			for (int i = 0; i < children.length; i++) {
				try{
				  String type = ((SimpleNode) children[i]).semanticAnalysis(ST, functionName);
	  
				  if(type.equals("boolean"))
				  builder.append("Z");
		
				  else if(type.equals("int"))
					builder.append("I" );
					
				  else if(type.equals("int[]"))
					builder.append("[I" );
	  
				  else if(type.equals(ST.className))
					builder.append("L" + ST.className);
	  
				  else builder.append("Ljava/lang/" + ((ASTLiteral) children[i]).identifier + ";");
				  
				} catch(Exception e){};
					  }
			
			builder.append(")Z\n");
		}
      }

      else {
        if(parentparentNode.identifier.contains("new ")) {
          String function = parentparentNode.identifier.split("new ")[1];
          builder.append("invokevirtual " + function + "." + parentNode.identifier + "(");
        }
          
		else builder.append("invokestatic " + parentparentNode.identifier + "." + parentNode.identifier + "(");
		
        for (int i = 0; i < children.length; i++) {
          try{
            String type = ((SimpleNode) children[i]).semanticAnalysis(ST, functionName);

            if(type.equals("boolean"))
            builder.append("Z");
  
            else if(type.equals("int"))
			  builder.append("I" );
			  
			else if(type.equals("int[]"))
              builder.append("[I" );

            else if(type.equals(ST.className))
              builder.append("L" + ST.className);

			else builder.append("Ljava/lang/" + ((ASTLiteral) children[i]).identifier + ";");
			
          } catch(Exception e){};
				}
        
		if(isStore(1))
			builder.append(")I\n");
		
		else builder.append(")V\n");
	  }
    }
	}  
}
/* JavaCC - OriginalChecksum=0d0f34f346a0ba514d6b41b522453a82 (do not edit this line) */
